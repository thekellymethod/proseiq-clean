
import { NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";
import { zipStore, ZipFile } from "@/lib/zip";
import { buildTextPdfBytes } from "@/lib/pdf";
import { stampPdfBates } from "@/lib/pdf-stamp";

function safeName(s: string) {
  return (s || "file").replace(/[^\w.\- ()]/g, "_").slice(0, 120);
}
function pad(n: number, width: number) {
  return String(n).padStart(width, "0");
}
async function fetchBytes(url: string) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
  const ab = await res.arrayBuffer();
  return new Uint8Array(ab);
}

function isPdf(mime?: string | null, filename?: string | null) {
  if (mime?.toLowerCase().includes("pdf")) return true;
  if (filename?.toLowerCase().endsWith(".pdf")) return true;
  return false;
}

export async function POST(_: Request, props: { params: Promise<{ jobId: string }> }) {
  const params = await props.params;
  const supabase = await createClient();
  const { data: auth } = await supabase.auth.getUser();
  if (!auth?.user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const { data: job, error: jErr } = await supabase
    .from("bundle_jobs")
    .select("id,case_id,draft_id,status,options")
    .eq("id", params.jobId)
    .single();

  if (jErr) return NextResponse.json({ error: jErr.message }, { status: 400 });

  await supabase.from("bundle_jobs").update({ status: "running", error: null }).eq("id", job.id);

  try {
    const opts = job.options ?? {};
    const batesPrefix = String(opts?.bates?.prefix ?? "PROSEIQ");
    const batesStart = Number(opts?.bates?.start ?? 1);
    const batesWidth = Number(opts?.bates?.width ?? 6);
    const batesMode = String(opts?.bates?.mode ?? "tierB"); // tierA | tierB

    const includeOriginals = opts?.includeOriginals !== false;
    const includeDraftPdf = !!opts?.includeDraftPdf;

    const { data: c, error: cErr } = await supabase
      .from("cases")
      .select("id,title,status,updated_at")
      .eq("id", job.case_id)
      .single();
    if (cErr) throw new Error(cErr.message);

    const { data: exhibits, error: xErr } = await supabase
      .from("case_exhibits")
      .select("id,code,title,description,sort,file_id,created_at,case_id")
      .eq("case_id", job.case_id)
      .order("sort", { ascending: true })
      .order("created_at", { ascending: true });
    if (xErr) throw new Error(xErr.message);

    const fileIds = (exhibits ?? []).map((x) => x.file_id).filter(Boolean) as string[];
    const filesById: Record<string, any> = {};
    if (fileIds.length) {
      const { data: files, error: fErr } = await supabase
        .from("case_files")
        .select("id,filename,mime,size,bucket,path,created_at,tags,status")
        .in("id", fileIds);
      if (fErr) throw new Error(fErr.message);
      for (const f of files ?? []) filesById[f.id] = f;
    }

    const outFiles: ZipFile[] = [];
    let cursor = batesStart;

    // Optional draft export (cover-style pdf; not per-page stamped unless you later convert to PDF pages)
    if (includeDraftPdf && job.draft_id) {
      const { data: d, error: dErr } = await supabase
        .from("case_drafts")
        .select("id,title,kind,content,updated_at,case_id")
        .eq("id", job.draft_id)
        .eq("case_id", job.case_id)
        .single();

      if (!dErr && d) {
        const pdf = buildTextPdfBytes({
          title: d.title || "Draft",
          meta: `Kind: ${d.kind} | Updated: ${new Date(d.updated_at).toLocaleString()}`,
          body: d.content || "",
        });
        outFiles.push({ name: `Draft/${safeName(d.title || "Draft")}.pdf`, data: new Uint8Array(pdf) });
      }
    }

    const manifestExhibits: any[] = [];

    for (const x of exhibits ?? []) {
      const f = x.file_id ? filesById[x.file_id] : null;

      // Cover always included
      const coverName = `Exhibits/${x.code}_${safeName(x.title || x.code)}__COVER.pdf`;

      // If no file linked: cover only, allocate a single Bates number to the cover.
      if (!f?.bucket || !f?.path) {
        const startLabel = `${batesPrefix}-${pad(cursor, batesWidth)}`;
        const endLabel = startLabel;

        const coverPdf = buildTextPdfBytes({
          title: `Exhibit ${x.code}: ${x.title || x.code}`,
          meta: `Case: ${c.title} | Exported: ${new Date().toLocaleString()}`,
          body:
            `Bates Range: ${startLabel} – ${endLabel}\n` +
            `Linked file: (none)\n\n` +
            (x.description ? `Description:\n${x.description}` : ""),
          footer: `Generated by ProseIQ • Exhibit ${x.code}`,
        });

        outFiles.push({ name: coverName, data: new Uint8Array(coverPdf) });

        await supabase
          .from("case_exhibits")
          .update({ page_count: 1, bates_start: cursor, bates_end: cursor })
          .eq("id", x.id);

        manifestExhibits.push({
          ...x,
          bates_start: cursor,
          bates_end: cursor,
          bates_start_label: startLabel,
          bates_end_label: endLabel,
          page_count: 1,
          file: null,
          bundle_files: { cover: coverName, original: null, stamped_pdf: null },
        });

        cursor += 1;
        continue;
      }

      // Signed URL fetch
      const signed = await supabase.storage.from(f.bucket).createSignedUrl(f.path, 180);
      if (signed.error || !signed.data?.signedUrl) {
        throw new Error(`Could not sign file: ${f.filename}`);
      }
      const bytes = await fetchBytes(signed.data.signedUrl);

      // Tier B: if PDF, stamp per page and count pages accurately
      const doTierB = batesMode === "tierB" && isPdf(f.mime, f.filename);

      let pageCount = 1;
      let startNum = cursor;
      let endNum = cursor;
      let stampedName: string | null = null;

      if (doTierB) {
        const stamped = await stampPdfBates(bytes, {
          prefix: batesPrefix,
          start: cursor,
          width: batesWidth,
          fontSize: 9,
          margin: 24,
        });

        pageCount = stamped.pageCount;
        startNum = stamped.start;
        endNum = stamped.end;
        cursor = endNum + 1;

        stampedName = `Exhibits/${x.code}_${safeName(f.filename)}__BATES.pdf`;
        outFiles.push({ name: stampedName, data: stamped.pdf });
      } else {
        // Tier A: allocate 1 bates "page" to the original artifact
        pageCount = 1;
        startNum = cursor;
        endNum = cursor;
        cursor = cursor + 1;
      }

      const startLabel = `${batesPrefix}-${pad(startNum, batesWidth)}`;
      const endLabel = `${batesPrefix}-${pad(endNum, batesWidth)}`;

      const coverPdf = buildTextPdfBytes({
        title: `Exhibit ${x.code}: ${x.title || x.code}`,
        meta: `Case: ${c.title} | Exported: ${new Date().toLocaleString()}`,
        body:
          `Bates Range: ${startLabel} – ${endLabel}\n` +
          `Page Count: ${pageCount}\n\n` +
          (x.description ? `Description:\n${x.description}\n\n` : "") +
          `Linked file:\n${f.filename}\n${f.mime ?? "unknown"} • ${f.size ?? 0} bytes\nStatus: ${f.status}\nTags: ${(f.tags ?? []).join(", ")}`,
        footer: `Generated by ProseIQ • Exhibit ${x.code}`,
      });

      outFiles.push({ name: coverName, data: new Uint8Array(coverPdf) });

      let originalName: string | null = null;
      if (includeOriginals) {
        originalName = `Exhibits/${x.code}_${safeName(f.filename)}`;
        outFiles.push({ name: originalName, data: bytes });
      }

      // Persist exhibit bates range
      await supabase
        .from("case_exhibits")
        .update({ page_count: pageCount, bates_start: startNum, bates_end: endNum })
        .eq("id", x.id);

      manifestExhibits.push({
        ...x,
        bates_start: startNum,
        bates_end: endNum,
        bates_start_label: startLabel,
        bates_end_label: endLabel,
        page_count: pageCount,
        file: f ?? null,
        bundle_files: { cover: coverName, original: originalName, stamped_pdf: stampedName },
      });
    }

    const manifest = {
      exported_at: new Date().toISOString(),
      case: c,
      draft_id: job.draft_id,
      bates: { prefix: batesPrefix, start: batesStart, width: batesWidth, assigned_through: cursor - 1, mode: batesMode },
      exhibits: manifestExhibits,
      bundle: outFiles.map((f) => f.name),
    };

    outFiles.push({
      name: "Manifest.json",
      data: new TextEncoder().encode(JSON.stringify(manifest, null, 2)),
    });

    const zip = zipStore(outFiles);

    const outBucket = "bundles";
    const outPath = `${auth.user.id}/${job.case_id}/bundle_${Date.now()}_${safeName(c.title)}.zip`;
    const up = await supabase.storage.from(outBucket).upload(outPath, zip, {
      contentType: "application/zip",
      upsert: false,
    });
    if (up.error) throw new Error(up.error.message);

    await supabase
      .from("bundle_jobs")
      .update({ status: "done", output_bucket: outBucket, output_path: outPath, output_bytes: zip.length, error: null })
      .eq("id", job.id);

    await supabase.from("audit_log").insert({
      entity: "bundle",
      entity_id: job.id,
      action: "export",
      metadata: { outBucket, outPath, bytes: zip.length, batesMode },
    });

    return NextResponse.json({ ok: true, output_bucket: outBucket, output_path: outPath });
  } catch (e: any) {
    await supabase.from("bundle_jobs").update({ status: "failed", error: String(e?.message ?? e) }).eq("id", job.id);
    return NextResponse.json({ error: String(e?.message ?? e) }, { status: 400 });
  }
}
