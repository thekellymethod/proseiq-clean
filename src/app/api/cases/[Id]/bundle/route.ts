
// src/app/api/cases/[id]/bundle/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";
import { zipStore, ZipFile } from "@/lib/zip";
import { buildTextPdfBytes } from "@/lib/pdf";

function safeName(s: string) {
  return (s || "file").replace(/[^\w.\- ()]/g, "_").slice(0, 120);
}
function pad(n: number, width: number) {
  return String(n).padStart(width, "0");
}

async function fetchBytes(url: string) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
  const ab = await res.arrayBuffer();
  return new Uint8Array(ab);
}

// Tier A page estimation (true per-page stamping is Tier B w/ pdf-lib)
function estimatePages(mime?: string | null) {
  if (!mime) return 1;
  if (mime.includes("pdf")) return 1;
  if (mime.startsWith("image/")) return 1;
  return 1;
}

function asUint8(x: any): Uint8Array {
  if (!x) return new Uint8Array();
  if (x instanceof Uint8Array) return x;
  // Buffer is a Uint8Array subclass, but keep explicit
  // eslint-disable-next-line no-undef
  if (typeof Buffer !== "undefined" && x instanceof Buffer) return new Uint8Array(x);
  return new Uint8Array(x);
}

export async function GET(req: Request, { params }: { params: { id: string } }) {
  const supabase = await createClient();
  const { data: auth } = await supabase.auth.getUser();
  if (!auth?.user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const url = new URL(req.url);
  const draftId = url.searchParams.get("draftId"); // optional
  const batesPrefix = String(url.searchParams.get("prefix") ?? "PROSEIQ").trim() || "PROSEIQ";
  const batesStart = Number(url.searchParams.get("batesStart") ?? 1);
  const batesWidth = Number(url.searchParams.get("batesWidth") ?? 6);

  // Case
  const { data: c, error: cErr } = await supabase
    .from("cases")
    .select("id,title,status,updated_at")
    .eq("id", params.id)
    .single();

  if (cErr) return NextResponse.json({ error: cErr.message }, { status: 400 });

  // Exhibits
  const { data: exhibits, error: xErr } = await supabase
    .from("case_exhibits")
    .select("id,code,title,description,sort,file_id,created_at,case_id")
    .eq("case_id", params.id)
    .order("sort", { ascending: true })
    .order("created_at", { ascending: true });

  if (xErr) return NextResponse.json({ error: xErr.message }, { status: 400 });

  // Files lookup
  const fileIds = (exhibits ?? []).map((x) => x.file_id).filter(Boolean) as string[];
  const filesById: Record<string, any> = {};

  if (fileIds.length) {
    const { data: files, error: fErr } = await supabase
      .from("case_files")
      .select("id,filename,mime,size,bucket,path,created_at,tags,status")
      .in("id", fileIds);

    if (fErr) return NextResponse.json({ error: fErr.message }, { status: 400 });
    for (const f of files ?? []) filesById[f.id] = f;
  }

  const outFiles: ZipFile[] = [];
  const bundleExhibits: any[] = [];

  // Draft PDF (optional)
  if (draftId) {
    const { data: d, error: dErr } = await supabase
      .from("case_drafts")
      .select("id,title,kind,content,updated_at,case_id")
      .eq("id", draftId)
      .eq("case_id", params.id)
      .single();

    if (!dErr && d) {
      const pdf = buildTextPdfBytes({
        title: d.title || "Draft",
        meta: `Kind: ${d.kind} | Updated: ${new Date(d.updated_at).toLocaleString()}`,
        body: d.content || "",
        footer: `Bates (Tier A): ${batesPrefix}-${pad(batesStart, batesWidth)} (draft cover only)`,
      });

      outFiles.push({
        name: `Draft/${safeName(d.title || "Draft")}.pdf`,
        data: asUint8(pdf),
      });
    }
  }

  // Bates allocation + cover PDFs + include original exhibit bytes
  let cursor = batesStart;

  for (const x of exhibits ?? []) {
    const f = x.file_id ? filesById[x.file_id] : null;

    const pages = estimatePages(f?.mime);
    const startNum = cursor;
    const endNum = cursor + pages - 1;
    cursor = endNum + 1;

    const startLabel = `${batesPrefix}-${pad(startNum, batesWidth)}`;
    const endLabel = `${batesPrefix}-${pad(endNum, batesWidth)}`;

    const coverPdf = buildTextPdfBytes({
      title: `Exhibit ${x.code}: ${x.title || x.code}`,
      meta: `Case: ${c.title} | Status: ${c.status} | Exported: ${new Date().toLocaleString()}`,
      body:
        `Bates Range: ${startLabel} – ${endLabel}\n` +
        `Estimated Pages (Tier A): ${pages}\n\n` +
        (x.description ? `Description:\n${x.description}\n\n` : "") +
        (f
          ? `Linked file:\n${f.filename}\n${f.mime ?? "unknown"} • ${f.size ?? 0} bytes\nUploaded: ${new Date(
              f.created_at
            ).toLocaleString()}\nStatus: ${f.status}\nTags: ${(f.tags ?? []).join(", ")}`
          : `Linked file: (none)`),
      footer: `Generated by ProseIQ • Exhibit ${x.code}`,
    });

    const coverName = `Exhibits/${x.code}_${safeName(x.title || x.code)}__COVER.pdf`;
    outFiles.push({ name: coverName, data: asUint8(coverPdf) });

    let originalName: string | null = null;

    if (f?.bucket && f?.path) {
      const signed = await supabase.storage.from(f.bucket).createSignedUrl(f.path, 120);
      if (!signed.error && signed.data?.signedUrl) {
        const bytes = await fetchBytes(signed.data.signedUrl);
        originalName = `Exhibits/${x.code}_${safeName(f.filename)}`;
        outFiles.push({ name: originalName, data: bytes });
      }
    }

    bundleExhibits.push({
      ...x,
      bates_start: startNum,
      bates_end: endNum,
      bates_start_label: startLabel,
      bates_end_label: endLabel,
      estimated_pages: pages,
      file: f ?? null,
      bundle_files: { cover: coverName, original: originalName },
    });
  }

  const manifest = {
    exported_at: new Date().toISOString(),
    case: c,
    draftId: draftId ?? null,
    bates: {
      prefix: batesPrefix,
      start: batesStart,
      width: batesWidth,
      assigned_through: cursor - 1,
    },
    exhibits: bundleExhibits,
    bundle: outFiles.map((f) => f.name),
    note:
      "Tier A assigns Bates ranges and stamps cover sheets; it includes original exhibit files in the ZIP. True per-page Bates stamping of PDFs is Tier B (pdf-lib).",
  };

  outFiles.push({
    name: "Manifest.json",
    data: new TextEncoder().encode(JSON.stringify(manifest, null, 2)),
  });

  const zip = zipStore(outFiles);

  return new NextResponse(zip, {
    status: 200,
    headers: {
      "Content-Type": "application/zip",
      "Content-Disposition": `attachment; filename="${safeName(c.title)}_bundle.zip"`,
      "Cache-Control": "no-store",
    },
  });
}
